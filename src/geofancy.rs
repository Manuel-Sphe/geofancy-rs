// This file is generated by rust-protobuf 1.6.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct CommandResult {
    // message fields
    pub status: CommandResult_CommandStatus,
    pub message: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CommandResult {
    pub fn new() -> CommandResult {
        ::std::default::Default::default()
    }

    // .geofancy.CommandResult.CommandStatus status = 1;

    pub fn clear_status(&mut self) {
        self.status = CommandResult_CommandStatus::COMMAND_OK;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: CommandResult_CommandStatus) {
        self.status = v;
    }

    pub fn get_status(&self) -> CommandResult_CommandStatus {
        self.status
    }

    // string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }
}

impl ::protobuf::Message for CommandResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != CommandResult_CommandStatus::COMMAND_OK {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status != CommandResult_CommandStatus::COMMAND_OK {
            os.write_enum(1, self.status.value())?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommandResult {
        CommandResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommandResult_CommandStatus>>(
                    "status",
                    |m: &CommandResult| { &m.status },
                    |m: &mut CommandResult| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CommandResult| { &m.message },
                    |m: &mut CommandResult| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandResult>(
                    "CommandResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommandResult {
        static mut instance: ::protobuf::lazy::Lazy<CommandResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandResult,
        };
        unsafe {
            instance.get(CommandResult::new)
        }
    }
}

impl ::protobuf::Clear for CommandResult {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommandResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommandResult_CommandStatus {
    COMMAND_OK = 0,
    COMMAND_FAILURE = 1,
}

impl ::protobuf::ProtobufEnum for CommandResult_CommandStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommandResult_CommandStatus> {
        match value {
            0 => ::std::option::Option::Some(CommandResult_CommandStatus::COMMAND_OK),
            1 => ::std::option::Option::Some(CommandResult_CommandStatus::COMMAND_FAILURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommandResult_CommandStatus] = &[
            CommandResult_CommandStatus::COMMAND_OK,
            CommandResult_CommandStatus::COMMAND_FAILURE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommandResult_CommandStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommandResult_CommandStatus {
}

impl ::std::default::Default for CommandResult_CommandStatus {
    fn default() -> Self {
        CommandResult_CommandStatus::COMMAND_OK
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandResult_CommandStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Document {
    // message fields
    pub collection: ::std::string::String,
    pub id: ::std::string::String,
    pub expiry: u64,
    pub notExist: bool,
    pub alreadyExist: bool,
    // message oneof groups
    pub geo: ::std::option::Option<Document_oneof_geo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Document_oneof_geo {
    point(Point),
    line(LineString),
    bounds(Bounds),
    geojson(::std::string::String),
}

impl Document {
    pub fn new() -> Document {
        ::std::default::Default::default()
    }

    // string collection = 1;

    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    pub fn get_collection(&self) -> &str {
        &self.collection
    }

    // string id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // .geofancy.Point point = 4;

    pub fn clear_point(&mut self) {
        self.geo = ::std::option::Option::None;
    }

    pub fn has_point(&self) -> bool {
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::point(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_point(&mut self, v: Point) {
        self.geo = ::std::option::Option::Some(Document_oneof_geo::point(v))
    }

    // Mutable pointer to the field.
    pub fn mut_point(&mut self) -> &mut Point {
        if let ::std::option::Option::Some(Document_oneof_geo::point(_)) = self.geo {
        } else {
            self.geo = ::std::option::Option::Some(Document_oneof_geo::point(Point::new()));
        }
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::point(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_point(&mut self) -> Point {
        if self.has_point() {
            match self.geo.take() {
                ::std::option::Option::Some(Document_oneof_geo::point(v)) => v,
                _ => panic!(),
            }
        } else {
            Point::new()
        }
    }

    pub fn get_point(&self) -> &Point {
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::point(ref v)) => v,
            _ => Point::default_instance(),
        }
    }

    // .geofancy.LineString line = 5;

    pub fn clear_line(&mut self) {
        self.geo = ::std::option::Option::None;
    }

    pub fn has_line(&self) -> bool {
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::line(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_line(&mut self, v: LineString) {
        self.geo = ::std::option::Option::Some(Document_oneof_geo::line(v))
    }

    // Mutable pointer to the field.
    pub fn mut_line(&mut self) -> &mut LineString {
        if let ::std::option::Option::Some(Document_oneof_geo::line(_)) = self.geo {
        } else {
            self.geo = ::std::option::Option::Some(Document_oneof_geo::line(LineString::new()));
        }
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::line(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_line(&mut self) -> LineString {
        if self.has_line() {
            match self.geo.take() {
                ::std::option::Option::Some(Document_oneof_geo::line(v)) => v,
                _ => panic!(),
            }
        } else {
            LineString::new()
        }
    }

    pub fn get_line(&self) -> &LineString {
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::line(ref v)) => v,
            _ => LineString::default_instance(),
        }
    }

    // .geofancy.Bounds bounds = 6;

    pub fn clear_bounds(&mut self) {
        self.geo = ::std::option::Option::None;
    }

    pub fn has_bounds(&self) -> bool {
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::bounds(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bounds(&mut self, v: Bounds) {
        self.geo = ::std::option::Option::Some(Document_oneof_geo::bounds(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bounds(&mut self) -> &mut Bounds {
        if let ::std::option::Option::Some(Document_oneof_geo::bounds(_)) = self.geo {
        } else {
            self.geo = ::std::option::Option::Some(Document_oneof_geo::bounds(Bounds::new()));
        }
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::bounds(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bounds(&mut self) -> Bounds {
        if self.has_bounds() {
            match self.geo.take() {
                ::std::option::Option::Some(Document_oneof_geo::bounds(v)) => v,
                _ => panic!(),
            }
        } else {
            Bounds::new()
        }
    }

    pub fn get_bounds(&self) -> &Bounds {
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::bounds(ref v)) => v,
            _ => Bounds::default_instance(),
        }
    }

    // string geojson = 7;

    pub fn clear_geojson(&mut self) {
        self.geo = ::std::option::Option::None;
    }

    pub fn has_geojson(&self) -> bool {
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::geojson(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_geojson(&mut self, v: ::std::string::String) {
        self.geo = ::std::option::Option::Some(Document_oneof_geo::geojson(v))
    }

    // Mutable pointer to the field.
    pub fn mut_geojson(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Document_oneof_geo::geojson(_)) = self.geo {
        } else {
            self.geo = ::std::option::Option::Some(Document_oneof_geo::geojson(::std::string::String::new()));
        }
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::geojson(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_geojson(&mut self) -> ::std::string::String {
        if self.has_geojson() {
            match self.geo.take() {
                ::std::option::Option::Some(Document_oneof_geo::geojson(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_geojson(&self) -> &str {
        match self.geo {
            ::std::option::Option::Some(Document_oneof_geo::geojson(ref v)) => v,
            _ => "",
        }
    }

    // uint64 expiry = 10;

    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: u64) {
        self.expiry = v;
    }

    pub fn get_expiry(&self) -> u64 {
        self.expiry
    }

    // bool notExist = 11;

    pub fn clear_notExist(&mut self) {
        self.notExist = false;
    }

    // Param is passed by value, moved
    pub fn set_notExist(&mut self, v: bool) {
        self.notExist = v;
    }

    pub fn get_notExist(&self) -> bool {
        self.notExist
    }

    // bool alreadyExist = 12;

    pub fn clear_alreadyExist(&mut self) {
        self.alreadyExist = false;
    }

    // Param is passed by value, moved
    pub fn set_alreadyExist(&mut self, v: bool) {
        self.alreadyExist = v;
    }

    pub fn get_alreadyExist(&self) -> bool {
        self.alreadyExist
    }
}

impl ::protobuf::Message for Document {
    fn is_initialized(&self) -> bool {
        if let Some(Document_oneof_geo::point(ref v)) = self.geo {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Document_oneof_geo::line(ref v)) = self.geo {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Document_oneof_geo::bounds(ref v)) = self.geo {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.geo = ::std::option::Option::Some(Document_oneof_geo::point(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.geo = ::std::option::Option::Some(Document_oneof_geo::line(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.geo = ::std::option::Option::Some(Document_oneof_geo::bounds(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.geo = ::std::option::Option::Some(Document_oneof_geo::geojson(is.read_string()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expiry = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.notExist = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.alreadyExist = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collection);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(10, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.notExist != false {
            my_size += 2;
        }
        if self.alreadyExist != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.geo {
            match v {
                &Document_oneof_geo::point(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Document_oneof_geo::line(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Document_oneof_geo::bounds(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Document_oneof_geo::geojson(ref v) => {
                    my_size += ::protobuf::rt::string_size(7, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collection.is_empty() {
            os.write_string(1, &self.collection)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if self.expiry != 0 {
            os.write_uint64(10, self.expiry)?;
        }
        if self.notExist != false {
            os.write_bool(11, self.notExist)?;
        }
        if self.alreadyExist != false {
            os.write_bool(12, self.alreadyExist)?;
        }
        if let ::std::option::Option::Some(ref v) = self.geo {
            match v {
                &Document_oneof_geo::point(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Document_oneof_geo::line(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Document_oneof_geo::bounds(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Document_oneof_geo::geojson(ref v) => {
                    os.write_string(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Document {
        Document::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &Document| { &m.collection },
                    |m: &mut Document| { &mut m.collection },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Document| { &m.id },
                    |m: &mut Document| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Point>(
                    "point",
                    Document::has_point,
                    Document::get_point,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LineString>(
                    "line",
                    Document::has_line,
                    Document::get_line,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Bounds>(
                    "bounds",
                    Document::has_bounds,
                    Document::get_bounds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "geojson",
                    Document::has_geojson,
                    Document::get_geojson,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "expiry",
                    |m: &Document| { &m.expiry },
                    |m: &mut Document| { &mut m.expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "notExist",
                    |m: &Document| { &m.notExist },
                    |m: &mut Document| { &mut m.notExist },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "alreadyExist",
                    |m: &Document| { &m.alreadyExist },
                    |m: &mut Document| { &mut m.alreadyExist },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Document>(
                    "Document",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Document {
        static mut instance: ::protobuf::lazy::Lazy<Document> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Document,
        };
        unsafe {
            instance.get(Document::new)
        }
    }
}

impl ::protobuf::Clear for Document {
    fn clear(&mut self) {
        self.clear_collection();
        self.clear_id();
        self.clear_point();
        self.clear_line();
        self.clear_bounds();
        self.clear_geojson();
        self.clear_expiry();
        self.clear_notExist();
        self.clear_alreadyExist();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Document {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Document {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bounds {
    // message fields
    pub southWest: ::protobuf::SingularPtrField<Coordinate>,
    pub northEast: ::protobuf::SingularPtrField<Coordinate>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Bounds {
    pub fn new() -> Bounds {
        ::std::default::Default::default()
    }

    // .geofancy.Coordinate southWest = 1;

    pub fn clear_southWest(&mut self) {
        self.southWest.clear();
    }

    pub fn has_southWest(&self) -> bool {
        self.southWest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_southWest(&mut self, v: Coordinate) {
        self.southWest = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_southWest(&mut self) -> &mut Coordinate {
        if self.southWest.is_none() {
            self.southWest.set_default();
        }
        self.southWest.as_mut().unwrap()
    }

    // Take field
    pub fn take_southWest(&mut self) -> Coordinate {
        self.southWest.take().unwrap_or_else(|| Coordinate::new())
    }

    pub fn get_southWest(&self) -> &Coordinate {
        self.southWest.as_ref().unwrap_or_else(|| Coordinate::default_instance())
    }

    // .geofancy.Coordinate northEast = 2;

    pub fn clear_northEast(&mut self) {
        self.northEast.clear();
    }

    pub fn has_northEast(&self) -> bool {
        self.northEast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_northEast(&mut self, v: Coordinate) {
        self.northEast = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_northEast(&mut self) -> &mut Coordinate {
        if self.northEast.is_none() {
            self.northEast.set_default();
        }
        self.northEast.as_mut().unwrap()
    }

    // Take field
    pub fn take_northEast(&mut self) -> Coordinate {
        self.northEast.take().unwrap_or_else(|| Coordinate::new())
    }

    pub fn get_northEast(&self) -> &Coordinate {
        self.northEast.as_ref().unwrap_or_else(|| Coordinate::default_instance())
    }
}

impl ::protobuf::Message for Bounds {
    fn is_initialized(&self) -> bool {
        for v in &self.southWest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.northEast {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.southWest)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.northEast)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.southWest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.northEast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.southWest.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.northEast.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bounds {
        Bounds::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coordinate>>(
                    "southWest",
                    |m: &Bounds| { &m.southWest },
                    |m: &mut Bounds| { &mut m.southWest },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coordinate>>(
                    "northEast",
                    |m: &Bounds| { &m.northEast },
                    |m: &mut Bounds| { &mut m.northEast },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Bounds>(
                    "Bounds",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Bounds {
        static mut instance: ::protobuf::lazy::Lazy<Bounds> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Bounds,
        };
        unsafe {
            instance.get(Bounds::new)
        }
    }
}

impl ::protobuf::Clear for Bounds {
    fn clear(&mut self) {
        self.clear_southWest();
        self.clear_northEast();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bounds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bounds {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GeoFence {
    // message fields
    pub id: ::std::string::String,
    pub endpoint: ::std::string::String,
    pub field_match: ::std::string::String,
    pub detect: ::std::vec::Vec<GeoFence_Detect>,
    pub commands: ::std::vec::Vec<GeoFence_Commands>,
    pub point: ::protobuf::SingularPtrField<Point>,
    pub distance: u64,
    // message oneof groups
    pub query: ::std::option::Option<GeoFence_oneof_query>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum GeoFence_oneof_query {
    nearby(GeoFence_QueryNearby),
    within(GeoFence_QueryWithin),
    intersects(GeoFence_QueryIntersects),
}

impl GeoFence {
    pub fn new() -> GeoFence {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string endpoint = 2;

    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }

    // .geofancy.GeoFence.QueryNearby nearby = 3;

    pub fn clear_nearby(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_nearby(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(GeoFence_oneof_query::nearby(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_nearby(&mut self, v: GeoFence_QueryNearby) {
        self.query = ::std::option::Option::Some(GeoFence_oneof_query::nearby(v))
    }

    // Mutable pointer to the field.
    pub fn mut_nearby(&mut self) -> &mut GeoFence_QueryNearby {
        if let ::std::option::Option::Some(GeoFence_oneof_query::nearby(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(GeoFence_oneof_query::nearby(GeoFence_QueryNearby::new()));
        }
        match self.query {
            ::std::option::Option::Some(GeoFence_oneof_query::nearby(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_nearby(&mut self) -> GeoFence_QueryNearby {
        if self.has_nearby() {
            match self.query.take() {
                ::std::option::Option::Some(GeoFence_oneof_query::nearby(v)) => v,
                _ => panic!(),
            }
        } else {
            GeoFence_QueryNearby::new()
        }
    }

    pub fn get_nearby(&self) -> &GeoFence_QueryNearby {
        match self.query {
            ::std::option::Option::Some(GeoFence_oneof_query::nearby(ref v)) => v,
            _ => GeoFence_QueryNearby::default_instance(),
        }
    }

    // .geofancy.GeoFence.QueryWithin within = 4;

    pub fn clear_within(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_within(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(GeoFence_oneof_query::within(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_within(&mut self, v: GeoFence_QueryWithin) {
        self.query = ::std::option::Option::Some(GeoFence_oneof_query::within(v))
    }

    // Mutable pointer to the field.
    pub fn mut_within(&mut self) -> &mut GeoFence_QueryWithin {
        if let ::std::option::Option::Some(GeoFence_oneof_query::within(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(GeoFence_oneof_query::within(GeoFence_QueryWithin::new()));
        }
        match self.query {
            ::std::option::Option::Some(GeoFence_oneof_query::within(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_within(&mut self) -> GeoFence_QueryWithin {
        if self.has_within() {
            match self.query.take() {
                ::std::option::Option::Some(GeoFence_oneof_query::within(v)) => v,
                _ => panic!(),
            }
        } else {
            GeoFence_QueryWithin::new()
        }
    }

    pub fn get_within(&self) -> &GeoFence_QueryWithin {
        match self.query {
            ::std::option::Option::Some(GeoFence_oneof_query::within(ref v)) => v,
            _ => GeoFence_QueryWithin::default_instance(),
        }
    }

    // .geofancy.GeoFence.QueryIntersects intersects = 5;

    pub fn clear_intersects(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_intersects(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(GeoFence_oneof_query::intersects(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_intersects(&mut self, v: GeoFence_QueryIntersects) {
        self.query = ::std::option::Option::Some(GeoFence_oneof_query::intersects(v))
    }

    // Mutable pointer to the field.
    pub fn mut_intersects(&mut self) -> &mut GeoFence_QueryIntersects {
        if let ::std::option::Option::Some(GeoFence_oneof_query::intersects(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(GeoFence_oneof_query::intersects(GeoFence_QueryIntersects::new()));
        }
        match self.query {
            ::std::option::Option::Some(GeoFence_oneof_query::intersects(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_intersects(&mut self) -> GeoFence_QueryIntersects {
        if self.has_intersects() {
            match self.query.take() {
                ::std::option::Option::Some(GeoFence_oneof_query::intersects(v)) => v,
                _ => panic!(),
            }
        } else {
            GeoFence_QueryIntersects::new()
        }
    }

    pub fn get_intersects(&self) -> &GeoFence_QueryIntersects {
        match self.query {
            ::std::option::Option::Some(GeoFence_oneof_query::intersects(ref v)) => v,
            _ => GeoFence_QueryIntersects::default_instance(),
        }
    }

    // string match = 6;

    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: ::std::string::String) {
        self.field_match = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_match(&mut self) -> &mut ::std::string::String {
        &mut self.field_match
    }

    // Take field
    pub fn take_field_match(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_match, ::std::string::String::new())
    }

    pub fn get_field_match(&self) -> &str {
        &self.field_match
    }

    // repeated .geofancy.GeoFence.Detect detect = 7;

    pub fn clear_detect(&mut self) {
        self.detect.clear();
    }

    // Param is passed by value, moved
    pub fn set_detect(&mut self, v: ::std::vec::Vec<GeoFence_Detect>) {
        self.detect = v;
    }

    // Mutable pointer to the field.
    pub fn mut_detect(&mut self) -> &mut ::std::vec::Vec<GeoFence_Detect> {
        &mut self.detect
    }

    // Take field
    pub fn take_detect(&mut self) -> ::std::vec::Vec<GeoFence_Detect> {
        ::std::mem::replace(&mut self.detect, ::std::vec::Vec::new())
    }

    pub fn get_detect(&self) -> &[GeoFence_Detect] {
        &self.detect
    }

    // repeated .geofancy.GeoFence.Commands commands = 8;

    pub fn clear_commands(&mut self) {
        self.commands.clear();
    }

    // Param is passed by value, moved
    pub fn set_commands(&mut self, v: ::std::vec::Vec<GeoFence_Commands>) {
        self.commands = v;
    }

    // Mutable pointer to the field.
    pub fn mut_commands(&mut self) -> &mut ::std::vec::Vec<GeoFence_Commands> {
        &mut self.commands
    }

    // Take field
    pub fn take_commands(&mut self) -> ::std::vec::Vec<GeoFence_Commands> {
        ::std::mem::replace(&mut self.commands, ::std::vec::Vec::new())
    }

    pub fn get_commands(&self) -> &[GeoFence_Commands] {
        &self.commands
    }

    // .geofancy.Point point = 9;

    pub fn clear_point(&mut self) {
        self.point.clear();
    }

    pub fn has_point(&self) -> bool {
        self.point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point(&mut self, v: Point) {
        self.point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_point(&mut self) -> &mut Point {
        if self.point.is_none() {
            self.point.set_default();
        }
        self.point.as_mut().unwrap()
    }

    // Take field
    pub fn take_point(&mut self) -> Point {
        self.point.take().unwrap_or_else(|| Point::new())
    }

    pub fn get_point(&self) -> &Point {
        self.point.as_ref().unwrap_or_else(|| Point::default_instance())
    }

    // uint64 distance = 10;

    pub fn clear_distance(&mut self) {
        self.distance = 0;
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: u64) {
        self.distance = v;
    }

    pub fn get_distance(&self) -> u64 {
        self.distance
    }
}

impl ::protobuf::Message for GeoFence {
    fn is_initialized(&self) -> bool {
        if let Some(GeoFence_oneof_query::nearby(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GeoFence_oneof_query::within(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(GeoFence_oneof_query::intersects(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(GeoFence_oneof_query::nearby(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(GeoFence_oneof_query::within(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(GeoFence_oneof_query::intersects(is.read_message()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_match)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.detect, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.commands, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.point)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.distance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.endpoint);
        }
        if !self.field_match.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.field_match);
        }
        for value in &self.detect {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        for value in &self.commands {
            my_size += ::protobuf::rt::enum_size(8, *value);
        };
        if let Some(ref v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.distance != 0 {
            my_size += ::protobuf::rt::value_size(10, self.distance, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.query {
            match v {
                &GeoFence_oneof_query::nearby(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GeoFence_oneof_query::within(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &GeoFence_oneof_query::intersects(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.endpoint.is_empty() {
            os.write_string(2, &self.endpoint)?;
        }
        if !self.field_match.is_empty() {
            os.write_string(6, &self.field_match)?;
        }
        for v in &self.detect {
            os.write_enum(7, v.value())?;
        };
        for v in &self.commands {
            os.write_enum(8, v.value())?;
        };
        if let Some(ref v) = self.point.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.distance != 0 {
            os.write_uint64(10, self.distance)?;
        }
        if let ::std::option::Option::Some(ref v) = self.query {
            match v {
                &GeoFence_oneof_query::nearby(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GeoFence_oneof_query::within(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &GeoFence_oneof_query::intersects(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeoFence {
        GeoFence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &GeoFence| { &m.id },
                    |m: &mut GeoFence| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoint",
                    |m: &GeoFence| { &m.endpoint },
                    |m: &mut GeoFence| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GeoFence_QueryNearby>(
                    "nearby",
                    GeoFence::has_nearby,
                    GeoFence::get_nearby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GeoFence_QueryWithin>(
                    "within",
                    GeoFence::has_within,
                    GeoFence::get_within,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GeoFence_QueryIntersects>(
                    "intersects",
                    GeoFence::has_intersects,
                    GeoFence::get_intersects,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "match",
                    |m: &GeoFence| { &m.field_match },
                    |m: &mut GeoFence| { &mut m.field_match },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GeoFence_Detect>>(
                    "detect",
                    |m: &GeoFence| { &m.detect },
                    |m: &mut GeoFence| { &mut m.detect },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GeoFence_Commands>>(
                    "commands",
                    |m: &GeoFence| { &m.commands },
                    |m: &mut GeoFence| { &mut m.commands },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                    "point",
                    |m: &GeoFence| { &m.point },
                    |m: &mut GeoFence| { &mut m.point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "distance",
                    |m: &GeoFence| { &m.distance },
                    |m: &mut GeoFence| { &mut m.distance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeoFence>(
                    "GeoFence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeoFence {
        static mut instance: ::protobuf::lazy::Lazy<GeoFence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeoFence,
        };
        unsafe {
            instance.get(GeoFence::new)
        }
    }
}

impl ::protobuf::Clear for GeoFence {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_endpoint();
        self.clear_nearby();
        self.clear_within();
        self.clear_intersects();
        self.clear_field_match();
        self.clear_detect();
        self.clear_commands();
        self.clear_point();
        self.clear_distance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeoFence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoFence {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GeoFence_QueryNearby {
    // message fields
    pub collection: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GeoFence_QueryNearby {
    pub fn new() -> GeoFence_QueryNearby {
        ::std::default::Default::default()
    }

    // string collection = 1;

    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    pub fn get_collection(&self) -> &str {
        &self.collection
    }
}

impl ::protobuf::Message for GeoFence_QueryNearby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collection.is_empty() {
            os.write_string(1, &self.collection)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeoFence_QueryNearby {
        GeoFence_QueryNearby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &GeoFence_QueryNearby| { &m.collection },
                    |m: &mut GeoFence_QueryNearby| { &mut m.collection },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeoFence_QueryNearby>(
                    "GeoFence_QueryNearby",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeoFence_QueryNearby {
        static mut instance: ::protobuf::lazy::Lazy<GeoFence_QueryNearby> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeoFence_QueryNearby,
        };
        unsafe {
            instance.get(GeoFence_QueryNearby::new)
        }
    }
}

impl ::protobuf::Clear for GeoFence_QueryNearby {
    fn clear(&mut self) {
        self.clear_collection();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeoFence_QueryNearby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoFence_QueryNearby {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GeoFence_QueryWithin {
    // message fields
    pub collection: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GeoFence_QueryWithin {
    pub fn new() -> GeoFence_QueryWithin {
        ::std::default::Default::default()
    }

    // string collection = 1;

    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    pub fn get_collection(&self) -> &str {
        &self.collection
    }
}

impl ::protobuf::Message for GeoFence_QueryWithin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collection.is_empty() {
            os.write_string(1, &self.collection)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeoFence_QueryWithin {
        GeoFence_QueryWithin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &GeoFence_QueryWithin| { &m.collection },
                    |m: &mut GeoFence_QueryWithin| { &mut m.collection },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeoFence_QueryWithin>(
                    "GeoFence_QueryWithin",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeoFence_QueryWithin {
        static mut instance: ::protobuf::lazy::Lazy<GeoFence_QueryWithin> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeoFence_QueryWithin,
        };
        unsafe {
            instance.get(GeoFence_QueryWithin::new)
        }
    }
}

impl ::protobuf::Clear for GeoFence_QueryWithin {
    fn clear(&mut self) {
        self.clear_collection();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeoFence_QueryWithin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoFence_QueryWithin {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GeoFence_QueryIntersects {
    // message fields
    pub collection: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GeoFence_QueryIntersects {
    pub fn new() -> GeoFence_QueryIntersects {
        ::std::default::Default::default()
    }

    // string collection = 1;

    pub fn clear_collection(&mut self) {
        self.collection.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection(&mut self, v: ::std::string::String) {
        self.collection = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection(&mut self) -> &mut ::std::string::String {
        &mut self.collection
    }

    // Take field
    pub fn take_collection(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection, ::std::string::String::new())
    }

    pub fn get_collection(&self) -> &str {
        &self.collection
    }
}

impl ::protobuf::Message for GeoFence_QueryIntersects {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collection.is_empty() {
            os.write_string(1, &self.collection)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GeoFence_QueryIntersects {
        GeoFence_QueryIntersects::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection",
                    |m: &GeoFence_QueryIntersects| { &m.collection },
                    |m: &mut GeoFence_QueryIntersects| { &mut m.collection },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GeoFence_QueryIntersects>(
                    "GeoFence_QueryIntersects",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GeoFence_QueryIntersects {
        static mut instance: ::protobuf::lazy::Lazy<GeoFence_QueryIntersects> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GeoFence_QueryIntersects,
        };
        unsafe {
            instance.get(GeoFence_QueryIntersects::new)
        }
    }
}

impl ::protobuf::Clear for GeoFence_QueryIntersects {
    fn clear(&mut self) {
        self.clear_collection();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GeoFence_QueryIntersects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoFence_QueryIntersects {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GeoFence_Detect {
    INSIDE = 0,
    OUTSIDE = 1,
    ENTER = 2,
    EXIT = 3,
    CROSS = 4,
}

impl ::protobuf::ProtobufEnum for GeoFence_Detect {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GeoFence_Detect> {
        match value {
            0 => ::std::option::Option::Some(GeoFence_Detect::INSIDE),
            1 => ::std::option::Option::Some(GeoFence_Detect::OUTSIDE),
            2 => ::std::option::Option::Some(GeoFence_Detect::ENTER),
            3 => ::std::option::Option::Some(GeoFence_Detect::EXIT),
            4 => ::std::option::Option::Some(GeoFence_Detect::CROSS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GeoFence_Detect] = &[
            GeoFence_Detect::INSIDE,
            GeoFence_Detect::OUTSIDE,
            GeoFence_Detect::ENTER,
            GeoFence_Detect::EXIT,
            GeoFence_Detect::CROSS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GeoFence_Detect", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GeoFence_Detect {
}

impl ::std::default::Default for GeoFence_Detect {
    fn default() -> Self {
        GeoFence_Detect::INSIDE
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoFence_Detect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GeoFence_Commands {
    SET = 0,
    DEL = 1,
    DROP = 2,
}

impl ::protobuf::ProtobufEnum for GeoFence_Commands {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GeoFence_Commands> {
        match value {
            0 => ::std::option::Option::Some(GeoFence_Commands::SET),
            1 => ::std::option::Option::Some(GeoFence_Commands::DEL),
            2 => ::std::option::Option::Some(GeoFence_Commands::DROP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GeoFence_Commands] = &[
            GeoFence_Commands::SET,
            GeoFence_Commands::DEL,
            GeoFence_Commands::DROP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GeoFence_Commands", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GeoFence_Commands {
}

impl ::std::default::Default for GeoFence_Commands {
    fn default() -> Self {
        GeoFence_Commands::SET
    }
}

impl ::protobuf::reflect::ProtobufValue for GeoFence_Commands {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Point {
    // message fields
    pub coord: ::protobuf::SingularPtrField<Coordinate>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Point {
    pub fn new() -> Point {
        ::std::default::Default::default()
    }

    // .geofancy.Coordinate coord = 1;

    pub fn clear_coord(&mut self) {
        self.coord.clear();
    }

    pub fn has_coord(&self) -> bool {
        self.coord.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coord(&mut self, v: Coordinate) {
        self.coord = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coord(&mut self) -> &mut Coordinate {
        if self.coord.is_none() {
            self.coord.set_default();
        }
        self.coord.as_mut().unwrap()
    }

    // Take field
    pub fn take_coord(&mut self) -> Coordinate {
        self.coord.take().unwrap_or_else(|| Coordinate::new())
    }

    pub fn get_coord(&self) -> &Coordinate {
        self.coord.as_ref().unwrap_or_else(|| Coordinate::default_instance())
    }
}

impl ::protobuf::Message for Point {
    fn is_initialized(&self) -> bool {
        for v in &self.coord {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.coord)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.coord.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.coord.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Point {
        Point::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coordinate>>(
                    "coord",
                    |m: &Point| { &m.coord },
                    |m: &mut Point| { &mut m.coord },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Point>(
                    "Point",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Point {
        static mut instance: ::protobuf::lazy::Lazy<Point> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Point,
        };
        unsafe {
            instance.get(Point::new)
        }
    }
}

impl ::protobuf::Clear for Point {
    fn clear(&mut self) {
        self.clear_coord();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Point {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LineString {
    // message fields
    pub coords: ::protobuf::RepeatedField<Coordinate>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LineString {
    pub fn new() -> LineString {
        ::std::default::Default::default()
    }

    // repeated .geofancy.Coordinate coords = 1;

    pub fn clear_coords(&mut self) {
        self.coords.clear();
    }

    // Param is passed by value, moved
    pub fn set_coords(&mut self, v: ::protobuf::RepeatedField<Coordinate>) {
        self.coords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_coords(&mut self) -> &mut ::protobuf::RepeatedField<Coordinate> {
        &mut self.coords
    }

    // Take field
    pub fn take_coords(&mut self) -> ::protobuf::RepeatedField<Coordinate> {
        ::std::mem::replace(&mut self.coords, ::protobuf::RepeatedField::new())
    }

    pub fn get_coords(&self) -> &[Coordinate] {
        &self.coords
    }
}

impl ::protobuf::Message for LineString {
    fn is_initialized(&self) -> bool {
        for v in &self.coords {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.coords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.coords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.coords {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LineString {
        LineString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coordinate>>(
                    "coords",
                    |m: &LineString| { &m.coords },
                    |m: &mut LineString| { &mut m.coords },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LineString>(
                    "LineString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LineString {
        static mut instance: ::protobuf::lazy::Lazy<LineString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LineString,
        };
        unsafe {
            instance.get(LineString::new)
        }
    }
}

impl ::protobuf::Clear for LineString {
    fn clear(&mut self) {
        self.clear_coords();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LineString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LineString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Coordinate {
    // message fields
    pub lat: f64,
    pub lng: f64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Coordinate {
    pub fn new() -> Coordinate {
        ::std::default::Default::default()
    }

    // double lat = 1;

    pub fn clear_lat(&mut self) {
        self.lat = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: f64) {
        self.lat = v;
    }

    pub fn get_lat(&self) -> f64 {
        self.lat
    }

    // double lng = 2;

    pub fn clear_lng(&mut self) {
        self.lng = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lng(&mut self, v: f64) {
        self.lng = v;
    }

    pub fn get_lng(&self) -> f64 {
        self.lng
    }
}

impl ::protobuf::Message for Coordinate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.lat = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.lng = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.lat != 0. {
            my_size += 9;
        }
        if self.lng != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.lat != 0. {
            os.write_double(1, self.lat)?;
        }
        if self.lng != 0. {
            os.write_double(2, self.lng)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Coordinate {
        Coordinate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "lat",
                    |m: &Coordinate| { &m.lat },
                    |m: &mut Coordinate| { &mut m.lat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "lng",
                    |m: &Coordinate| { &m.lng },
                    |m: &mut Coordinate| { &mut m.lng },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Coordinate>(
                    "Coordinate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Coordinate {
        static mut instance: ::protobuf::lazy::Lazy<Coordinate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Coordinate,
        };
        unsafe {
            instance.get(Coordinate::new)
        }
    }
}

impl ::protobuf::Clear for Coordinate {
    fn clear(&mut self) {
        self.clear_lat();
        self.clear_lng();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Coordinate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Coordinate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchString {
    // message fields
    pub value: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SearchString {
    pub fn new() -> SearchString {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }
}

impl ::protobuf::Message for SearchString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchString {
        SearchString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &SearchString| { &m.value },
                    |m: &mut SearchString| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SearchString>(
                    "SearchString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SearchString {
        static mut instance: ::protobuf::lazy::Lazy<SearchString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SearchString,
        };
        unsafe {
            instance.get(SearchString::new)
        }
    }
}

impl ::protobuf::Clear for SearchString {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0egeofancy.proto\x12\x08geofancy\"\x9e\x01\n\rCommandResult\x12=\n\
    \x06status\x18\x01\x20\x01(\x0e2%.geofancy.CommandResult.CommandStatusR\
    \x06status\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"4\n\rCom\
    mandStatus\x12\x0e\n\nCOMMAND_OK\x10\0\x12\x13\n\x0fCOMMAND_FAILURE\x10\
    \x01\"\xb6\x02\n\x08Document\x12\x1e\n\ncollection\x18\x01\x20\x01(\tR\n\
    collection\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12'\n\x05point\x18\
    \x04\x20\x01(\x0b2\x0f.geofancy.PointH\0R\x05point\x12*\n\x04line\x18\
    \x05\x20\x01(\x0b2\x14.geofancy.LineStringH\0R\x04line\x12*\n\x06bounds\
    \x18\x06\x20\x01(\x0b2\x10.geofancy.BoundsH\0R\x06bounds\x12\x1a\n\x07ge\
    ojson\x18\x07\x20\x01(\tH\0R\x07geojson\x12\x16\n\x06expiry\x18\n\x20\
    \x01(\x04R\x06expiry\x12\x1a\n\x08notExist\x18\x0b\x20\x01(\x08R\x08notE\
    xist\x12\"\n\x0calreadyExist\x18\x0c\x20\x01(\x08R\x0calreadyExistB\x05\
    \n\x03geo\"p\n\x06Bounds\x122\n\tsouthWest\x18\x01\x20\x01(\x0b2\x14.geo\
    fancy.CoordinateR\tsouthWest\x122\n\tnorthEast\x18\x02\x20\x01(\x0b2\x14\
    .geofancy.CoordinateR\tnorthEast\"\xba\x05\n\x08GeoFence\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12\x1a\n\x08endpoint\x18\x02\x20\x01(\tR\x08\
    endpoint\x128\n\x06nearby\x18\x03\x20\x01(\x0b2\x1e.geofancy.GeoFence.Qu\
    eryNearbyH\0R\x06nearby\x128\n\x06within\x18\x04\x20\x01(\x0b2\x1e.geofa\
    ncy.GeoFence.QueryWithinH\0R\x06within\x12D\n\nintersects\x18\x05\x20\
    \x01(\x0b2\".geofancy.GeoFence.QueryIntersectsH\0R\nintersects\x12\x14\n\
    \x05match\x18\x06\x20\x01(\tR\x05match\x121\n\x06detect\x18\x07\x20\x03(\
    \x0e2\x19.geofancy.GeoFence.DetectR\x06detect\x127\n\x08commands\x18\x08\
    \x20\x03(\x0e2\x1b.geofancy.GeoFence.CommandsR\x08commands\x12%\n\x05poi\
    nt\x18\t\x20\x01(\x0b2\x0f.geofancy.PointR\x05point\x12\x1a\n\x08distanc\
    e\x18\n\x20\x01(\x04R\x08distance\x1a-\n\x0bQueryNearby\x12\x1e\n\ncolle\
    ction\x18\x01\x20\x01(\tR\ncollection\x1a-\n\x0bQueryWithin\x12\x1e\n\nc\
    ollection\x18\x01\x20\x01(\tR\ncollection\x1a1\n\x0fQueryIntersects\x12\
    \x1e\n\ncollection\x18\x01\x20\x01(\tR\ncollection\"A\n\x06Detect\x12\n\
    \n\x06INSIDE\x10\0\x12\x0b\n\x07OUTSIDE\x10\x01\x12\t\n\x05ENTER\x10\x02\
    \x12\x08\n\x04EXIT\x10\x03\x12\t\n\x05CROSS\x10\x04\"&\n\x08Commands\x12\
    \x07\n\x03SET\x10\0\x12\x07\n\x03DEL\x10\x01\x12\x08\n\x04DROP\x10\x02B\
    \x07\n\x05query\"3\n\x05Point\x12*\n\x05coord\x18\x01\x20\x01(\x0b2\x14.\
    geofancy.CoordinateR\x05coord\":\n\nLineString\x12,\n\x06coords\x18\x01\
    \x20\x03(\x0b2\x14.geofancy.CoordinateR\x06coords\"0\n\nCoordinate\x12\
    \x10\n\x03lat\x18\x01\x20\x01(\x01R\x03lat\x12\x10\n\x03lng\x18\x02\x20\
    \x01(\x01R\x03lng\"$\n\x0cSearchString\x12\x14\n\x05value\x18\x01\x20\
    \x01(\tR\x05value2\xd7\x02\n\x0fGeofancyService\x12>\n\rCreateWebHook\
    \x12\x12.geofancy.GeoFence\x1a\x17.geofancy.CommandResult\"\0\x12B\n\rDe\
    leteWebHook\x12\x16.geofancy.SearchString\x1a\x17.geofancy.CommandResult\
    \"\0\x12<\n\x0bSetDocument\x12\x12.geofancy.Document\x1a\x17.geofancy.Co\
    mmandResult\"\0\x12?\n\x0eDeleteDocument\x12\x12.geofancy.Document\x1a\
    \x17.geofancy.CommandResult\"\0\x12A\n\x10DeleteCollection\x12\x12.geofa\
    ncy.Document\x1a\x17.geofancy.CommandResult\"\0B6\n#za.co.movinggauteng.\
    protos.geofancyB\rGeofancyProtoP\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
